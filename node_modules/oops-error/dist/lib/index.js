"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defensiveGet = exports.programmerOops = exports.newProgrammerOops = exports.operationalOops = exports.newOperationalOops = exports.assert = exports.operationalErrorHandler = exports.programmerErrorHandler = exports.getErrorCategory = exports.Oops = void 0;
const uuid_1 = require("uuid");
const util_1 = require("./util");
const constants = {
    OperationalError: 'OperationalError',
    ProgrammerError: 'ProgrammerError',
};
class Oops extends Error {
    constructor(options) {
        super(options.message);
        this.fullStack = () => {
            let str = this.stack || '';
            if (this.context) {
                str = str.replace(this.message + '\n', this.message + ' ' + (0, util_1.stringifyContext)(this.context) + '\n');
            }
            if (this.cause) {
                const cause = this.cause;
                str += '\n' + (cause.fullStack ? cause.fullStack() : cause.stack);
            }
            return str;
        };
        this.contextValue = (key) => {
            var _a;
            if (this.context && this.context[key]) {
                return this.context[key];
            }
            if (typeof ((_a = this.cause) === null || _a === void 0 ? void 0 : _a.contextValue) === 'function') {
                return this.cause.contextValue(key);
            }
            return undefined;
        };
        Error.captureStackTrace(this, this.constructor);
        this.name = options.name || options.category;
        this.category = options.category;
        this.context = options.context;
        this.cause = options.cause;
        this.id = (0, uuid_1.v4)();
    }
}
exports.Oops = Oops;
const getErrorCategory = (err) => {
    if (err.category) {
        return err.category;
    }
    return constants.ProgrammerError;
};
exports.getErrorCategory = getErrorCategory;
const programmerErrorHandler = (message, context) => {
    return (err) => {
        throw new Oops({
            message,
            category: (0, exports.getErrorCategory)(err),
            cause: err,
            context,
        });
    };
};
exports.programmerErrorHandler = programmerErrorHandler;
const operationalErrorHandler = (message, context) => {
    return (err) => {
        throw new Oops({
            message,
            category: constants.OperationalError,
            cause: err,
            context,
        });
    };
};
exports.operationalErrorHandler = operationalErrorHandler;
const assert = (value, message, context) => {
    if (!Boolean(value)) {
        throw new Oops({
            message,
            category: constants.OperationalError,
            context,
        });
    }
};
exports.assert = assert;
const newOperationalOops = (message, context, cause) => {
    return new Oops({
        message,
        category: constants.OperationalError,
        context,
        cause,
    });
};
exports.newOperationalOops = newOperationalOops;
const operationalOops = (message, context) => {
    throw (0, exports.newOperationalOops)(message, context);
};
exports.operationalOops = operationalOops;
const newProgrammerOops = (message, context, cause) => {
    return new Oops({
        message,
        category: constants.ProgrammerError,
        context,
        cause,
    });
};
exports.newProgrammerOops = newProgrammerOops;
const programmerOops = (message, context) => {
    throw (0, exports.newProgrammerOops)(message, context);
};
exports.programmerOops = programmerOops;
const defensiveGet = (getter) => {
    try {
        return getter();
    }
    catch (e) {
        return 'accessing value returned an error: ' + e;
    }
};
exports.defensiveGet = defensiveGet;
//# sourceMappingURL=index.js.map